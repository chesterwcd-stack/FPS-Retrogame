<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Maze FPS Shooter</title>

  <!-- Tailwind (OK via CDN for static deploys) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js + Pointer Lock Controls (v0.128 to match your build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

  <!-- Tone.js (for simple SFX) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0e0e0e; }
    #overlayMsg {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    #overlayMsg > div {
      background:rgba(0,0,0,.75); color:#fff; border:1px solid #3f3f3f;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      padding:14px 18px; border-radius:6px;
    }
  </style>
</head>
<body>
  <!-- HUD -->
  <div class="fixed top-2 left-2 text-xs text-white/90 font-mono z-50 space-y-1">
    <div id="hud-score">Score: 0</div>
    <div id="hud-health">Health: 100</div>
    <div id="hud-ammo">Ammo: 30</div>
    <div id="hud-tips" class="text-white/70">
      Click to lock cursor • WASD to move • Mouse to aim • Space/Click to shoot
    </div>
  </div>

  <!-- Canvas container -->
  <div id="container" style="width:100%;height:100%;position:relative;"></div>
  <div id="overlayMsg" class="hidden"><div id="overlayText"></div></div>

  <script type="module">
    /* =============== Minimal/no-op Firebase gate (keeps static deploys happy) =============== */
    // If you later want backend, wire it here and set ENABLE_BACKEND=true.
    const ENABLE_BACKEND = false;
    async function initializeFirebase() {
      console.info("Firebase disabled; running in local/offline mode.");
      initGame();
    }

    /* ===================================== Game ===================================== */
    const container = document.getElementById("container");
    const overlay = document.getElementById("overlayMsg");
    const overlayText = document.getElementById("overlayText");

    function showOverlay(text) {
      overlayText.textContent = text;
      overlay.classList.remove("hidden");
    }
    function hideOverlay() {
      overlay.classList.add("hidden");
    }

    // --- Universal WebGL-compatible renderer setup ---
function canGetWebGL(ctxName) {
  const c = document.createElement("canvas");
  const gl = c.getContext(ctxName, {
    antialias: false,
    alpha: false,
    stencil: false,
    depth: true,
    premultipliedAlpha: true,
  });
  return !!gl;
}

let renderer = null;
const rendererOpts = {
  antialias: false,
  alpha: false,
  depth: true,
  stencil: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default" // safer for Macs
};

try {
  if (canGetWebGL("webgl2")) {
    renderer = new THREE.WebGLRenderer(rendererOpts);
  } else if (canGetWebGL("webgl") && THREE.WebGL1Renderer) {
    renderer = new THREE.WebGL1Renderer(rendererOpts);
  } else if (canGetWebGL("webgl")) {
    renderer = new THREE.WebGLRenderer(rendererOpts);
  }
} catch (e) {
  renderer = null;
}

if (!renderer) {
  const msg = document.createElement("div");
  msg.style.position = "absolute";
  msg.style.top = "50%";
  msg.style.left = "50%";
  msg.style.transform = "translate(-50%,-50%)";
  msg.style.background = "rgba(0,0,0,.75)";
  msg.style.color = "#fff";
  msg.style.padding = "18px 22px";
  msg.style.border = "1px solid #3f3f3f";
  msg.style.font = "12px/1.4 monospace";
  msg.style.maxWidth = "560px";
  msg.style.textAlign = "center";
  msg.innerHTML =
    "⚠️ WebGL is unavailable.<br/>" +
    "Try a private window or Chrome/Firefox, and enable Hardware Acceleration.<br/>" +
    "<small>(Safari: Develop → Experimental Features → WebGL 2.0 + WebGL via Metal)</small>";
  container.appendChild(msg);
  throw new Error("WebGL not available");
}

const DPR = Math.min(window.devicePixelRatio || 1, 1.5);
renderer.setPixelRatio(DPR);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.LinearEncoding;
renderer.shadowMap.enabled = false;
container.appendChild(renderer.domElement);

    // ---- Scene / Camera / Controls
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0f0a);

    const camera = new THREE.PerspectiveCamera(
      70, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 1.6, 5);
    scene.add(camera);

    const controls = new THREE.PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    // Lights
    const hem = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
    scene.add(hem);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x133313 })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Targets
    const targets = new THREE.Group();
    scene.add(targets);
    const tGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
    const tMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });

    for (let i = 0; i < 24; i++) {
      const m = new THREE.Mesh(tGeo, tMat.clone());
      m.position.set((Math.random() - 0.5) * 40, 0.5 + Math.random() * 2, -10 - Math.random() * 60);
      m.material.color.offsetHSL(Math.random() * 0.1, 0.2, 0);
      m.userData.hp = 2;
      targets.add(m);
    }

    // Movement
    const keys = new Set();
    let velocity = new THREE.Vector3();
    const speed = 5;
    addEventListener("keydown", (e) => keys.add(e.code));
    addEventListener("keyup",   (e) => keys.delete(e.code));

    // Audio unlock on first gesture
    function unlockAudio() {
      if (Tone.context.state !== "running") {
        Tone.start().catch(() => {});
      }
      removeEventListener("click", unlockAudio);
      removeEventListener("touchstart", unlockAudio);
      removeEventListener("keydown", unlockAudio);
    }
    addEventListener("click", unlockAudio, { once:true });
    addEventListener("touchstart", unlockAudio, { once:true });
    addEventListener("keydown", unlockAudio, { once:true });

    const synth = new Tone.MembraneSynth().toDestination();

    // Shooting
    let canShoot = true;
    function shoot() {
      if (!canShoot) return;
      canShoot = false;
      setTimeout(() => (canShoot = true), 120);

      if (Tone.context.state === "running") {
        synth.triggerAttackRelease("A2", "16n");
      }

      const ray = new THREE.Raycaster(
        camera.getWorldPosition(new THREE.Vector3()),
        camera.getWorldDirection(new THREE.Vector3())
      );
      const hits = ray.intersectObjects(targets.children, false);
      if (hits.length) {
        const obj = hits[0].object;
        obj.userData.hp -= 1;
        if (obj.userData.hp <= 0) {
          targets.remove(obj);
          scene.remove(obj);
          score += 10;
          document.getElementById("hud-score").textContent = `Score: ${score}`;
        } else {
          obj.material.emissive = new THREE.Color(0x550000);
          setTimeout(() => (obj.material.emissive = new THREE.Color(0x000000)), 80);
        }
      }
    }

    // Pointer lock UX
    container.addEventListener("click", () => controls.lock());
    document.addEventListener("pointerlockchange", () => {
      const tips = document.getElementById("hud-tips");
      if (document.pointerLockElement === renderer.domElement) {
        tips.textContent = "Shoot: Space/Click • Move: WASD • Unlock: Esc";
        hideOverlay();
      } else {
        tips.textContent = "Click to lock cursor • WASD to move • Space/Click to shoot";
      }
    });

    addEventListener("keydown", (e) => { if (e.code === "Space") shoot(); });
    addEventListener("mousedown", () => {
      if (document.pointerLockElement === renderer.domElement) shoot();
    });

    // State
    let score = 0, health = 100, ammo = 30;

    // Loop
    let last = performance.now();
    function animate(now = performance.now()) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      velocity.set(0, 0, 0);
      if (keys.has("KeyW")) velocity.z -= 1;
      if (keys.has("KeyS")) velocity.z += 1;
      if (keys.has("KeyA")) velocity.x -= 1;
      if (keys.has("KeyD")) velocity.x += 1;
      if (velocity.lengthSq() > 0) velocity.normalize().multiplyScalar(speed * dt);

      controls.moveRight(velocity.x);
      controls.moveForward(velocity.z);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Resize
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    function initGame() {
      requestAnimationFrame(animate);
    }

    // Kick off
    initializeFirebase();
  </script>
</body>
</html>
